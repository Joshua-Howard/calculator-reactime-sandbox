{"ast":null,"code":"/* eslint-disable no-param-reassign */\n// traverses given tree by accessing children through coords array\nconst _require = require('./masterState'),\n      returnState = _require.returnState;\n\nfunction traverseTree(tree, coords) {\n  let curr = tree;\n  coords.forEach(coord => {\n    curr = curr.children[coord];\n  });\n  return curr;\n}\n\nmodule.exports = (origin, mode) => {\n  // recursively change state of tree\n  function jump(target, coords = []) {\n    const originNode = traverseTree(origin.tree, coords); // set the state of the origin tree if the component is stateful\n\n    if (originNode.component.setState) {\n      originNode.component.setState(target.state, () => {\n        // iterate through new children once state has been set\n        target.children.forEach((child, i) => {\n          jump(child, coords.concat(i));\n        });\n      });\n    } else {\n      // if component uses hooks, traverse through the memoize tree\n      let current = originNode.component;\n      let index = 0;\n      const hooks = returnState(); // while loop through the memoize tree\n\n      while (current && current.queue) {\n        // allows time travel with useEffect\n        current.queue.dispatch(target.state[hooks[index]]); // Reassign the current value\n\n        current = current.next;\n        index += 2;\n      }\n    }\n  }\n\n  return target => {\n    // setting mode disables setState from posting messages to window\n    mode.jumping = true;\n    jump(target);\n    setTimeout(() => {\n      mode.jumping = false;\n    }, 100);\n  };\n};","map":{"version":3,"sources":["/Users/josh/Documents/GitHub/calculator-reactime-sandbox/src/reactime-module/timeJump.js"],"names":["require","returnState","traverseTree","tree","coords","curr","forEach","coord","children","module","exports","origin","mode","jump","target","originNode","component","setState","state","child","i","concat","current","index","hooks","queue","dispatch","next","jumping","setTimeout"],"mappings":"AAAA;AACA;iBACwBA,OAAO,CAAC,eAAD,C;MAAvBC,W,YAAAA,W;;AAER,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,MAA5B,EAAoC;AAClC,MAAIC,IAAI,GAAGF,IAAX;AACAC,EAAAA,MAAM,CAACE,OAAP,CAAeC,KAAK,IAAI;AACtBF,IAAAA,IAAI,GAAGA,IAAI,CAACG,QAAL,CAAcD,KAAd,CAAP;AACD,GAFD;AAGA,SAAOF,IAAP;AACD;;AAEDI,MAAM,CAACC,OAAP,GAAiB,CAACC,MAAD,EAASC,IAAT,KAAkB;AACjC;AACA,WAASC,IAAT,CAAcC,MAAd,EAAsBV,MAAM,GAAG,EAA/B,EAAmC;AACjC,UAAMW,UAAU,GAAGb,YAAY,CAACS,MAAM,CAACR,IAAR,EAAcC,MAAd,CAA/B,CADiC,CAEjC;;AACA,QAAIW,UAAU,CAACC,SAAX,CAAqBC,QAAzB,EAAmC;AACjCF,MAAAA,UAAU,CAACC,SAAX,CAAqBC,QAArB,CAA8BH,MAAM,CAACI,KAArC,EAA4C,MAAM;AAChD;AACAJ,QAAAA,MAAM,CAACN,QAAP,CAAgBF,OAAhB,CAAwB,CAACa,KAAD,EAAQC,CAAR,KAAc;AACpCP,UAAAA,IAAI,CAACM,KAAD,EAAQf,MAAM,CAACiB,MAAP,CAAcD,CAAd,CAAR,CAAJ;AACD,SAFD;AAGD,OALD;AAMD,KAPD,MAOO;AACL;AACA,UAAIE,OAAO,GAAGP,UAAU,CAACC,SAAzB;AACA,UAAIO,KAAK,GAAG,CAAZ;AACA,YAAMC,KAAK,GAAGvB,WAAW,EAAzB,CAJK,CAKL;;AACA,aAAOqB,OAAO,IAAIA,OAAO,CAACG,KAA1B,EAAiC;AAAE;AACjCH,QAAAA,OAAO,CAACG,KAAR,CAAcC,QAAd,CAAuBZ,MAAM,CAACI,KAAP,CAAaM,KAAK,CAACD,KAAD,CAAlB,CAAvB,EAD+B,CAE/B;;AACAD,QAAAA,OAAO,GAAGA,OAAO,CAACK,IAAlB;AACAJ,QAAAA,KAAK,IAAI,CAAT;AACD;AACF;AACF;;AAED,SAAOT,MAAM,IAAI;AACf;AACAF,IAAAA,IAAI,CAACgB,OAAL,GAAe,IAAf;AACAf,IAAAA,IAAI,CAACC,MAAD,CAAJ;AACAe,IAAAA,UAAU,CAAC,MAAM;AACfjB,MAAAA,IAAI,CAACgB,OAAL,GAAe,KAAf;AACD,KAFS,EAEP,GAFO,CAAV;AAGD,GAPD;AAQD,CAnCD","sourcesContent":["/* eslint-disable no-param-reassign */\n// traverses given tree by accessing children through coords array\nconst { returnState } = require('./masterState');\n\nfunction traverseTree(tree, coords) {\n  let curr = tree;\n  coords.forEach(coord => {\n    curr = curr.children[coord];\n  });\n  return curr;\n}\n\nmodule.exports = (origin, mode) => {\n  // recursively change state of tree\n  function jump(target, coords = []) {\n    const originNode = traverseTree(origin.tree, coords);\n    // set the state of the origin tree if the component is stateful\n    if (originNode.component.setState) {\n      originNode.component.setState(target.state, () => {\n        // iterate through new children once state has been set\n        target.children.forEach((child, i) => {\n          jump(child, coords.concat(i));\n        });\n      });\n    } else {\n      // if component uses hooks, traverse through the memoize tree\n      let current = originNode.component;\n      let index = 0;\n      const hooks = returnState();\n      // while loop through the memoize tree\n      while (current && current.queue) { // allows time travel with useEffect\n        current.queue.dispatch(target.state[hooks[index]]);\n        // Reassign the current value\n        current = current.next;\n        index += 2;\n      }\n    }\n  }\n\n  return target => {\n    // setting mode disables setState from posting messages to window\n    mode.jumping = true;\n    jump(target);\n    setTimeout(() => {\n      mode.jumping = false;\n    }, 100);\n  };\n};\n"]},"metadata":{},"sourceType":"module"}