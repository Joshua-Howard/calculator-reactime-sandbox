{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable func-names */\n\n/* eslint-disable no-use-before-define */\n\n/* eslint-disable no-param-reassign */\n// links component state tree to library\n// changes the setState method to also update our snapshot\nconst Tree = require('./tree');\n\nconst astParser = require('./astParser');\n\nconst _require = require('./masterState'),\n      saveState = _require.saveState;\n\nmodule.exports = (snap, mode) => {\n  let fiberRoot = null;\n  let astHooks;\n  let concurrent = false; // flag to check if we are in concurrent mode\n\n  function sendSnapshot() {\n    // don't send messages while jumping or while paused\n    // DEV: So that when we are jumping to an old snapshot it\n    // wouldn't think we want to create new snapshots\n    if (mode.jumping || mode.paused) return;\n    const payload = snap.tree.getCopy(); // console.log('payload', payload);\n\n    window.postMessage({\n      action: 'recordSnap',\n      payload\n    });\n  }\n\n  function changeSetState(component) {\n    // check that setState hasn't been changed yet\n    if (component.setState.linkFiberChanged) return; // make a copy of setState\n\n    const oldSetState = component.setState.bind(component); // replace component's setState so developer doesn't change syntax\n    // component.setState = newSetState.bind(component);\n\n    component.setState = (state, callback = () => {}) => {\n      // don't do anything if state is locked\n      // UNLESS we are currently jumping through time\n      if (mode.locked && !mode.jumping) return; // continue normal setState functionality, except add sending message middleware\n\n      oldSetState(state, () => {\n        updateSnapShotTree();\n        sendSnapshot();\n        callback.bind(component)();\n      });\n    };\n\n    component.setState.linkFiberChanged = true;\n  }\n\n  function changeUseState(component) {\n    if (component.queue.dispatch.linkFiberChanged) return; // store the original dispatch function definition\n\n    const oldDispatch = component.queue.dispatch.bind(component.queue); // redefine the dispatch function so we can inject our code\n\n    component.queue.dispatch = (fiber, queue, action) => {\n      // don't do anything if state is locked\n      if (mode.locked && !mode.jumping) return;\n      oldDispatch(fiber, queue, action); // setTimeout(() => {\n\n      updateSnapShotTree();\n      sendSnapshot(); // }, 100);\n    };\n\n    component.queue.dispatch.linkFiberChanged = true;\n  } // Helper function to traverse through the memoized state\n  // TODO: WE NEED TO CLEAN IT UP A BIT\n\n\n  function traverseHooks(memoizedState) {\n    // Declare variables and assigned to 0th index and an empty object, respectively\n    const memoized = {};\n    let index = 0;\n    astHooks = Object.values(astHooks); // while memoizedState is truthy, save the value to the object\n\n    while (memoizedState && memoizedState.queue) {\n      // prevents useEffect from crashing on load\n      // if (memoizedState.next.queue === null) { // prevents double pushing snapshot updates\n      changeUseState(memoizedState); // }\n      // memoized[astHooks[index]] = memoizedState.memoizedState;\n\n      memoized[astHooks[index]] = memoizedState.memoizedState; // Reassign memoizedState to its next value\n\n      memoizedState = memoizedState.next; // Increment the index by 2\n\n      index += 2;\n    }\n\n    return memoized;\n  }\n\n  function createTree(currentFiber, tree = new Tree('root')) {\n    if (!currentFiber) return tree;\n    const sibling = currentFiber.sibling,\n          stateNode = currentFiber.stateNode,\n          child = currentFiber.child,\n          memoizedState = currentFiber.memoizedState,\n          elementType = currentFiber.elementType;\n    let nextTree = tree; // check if stateful component\n\n    if (stateNode && stateNode.state) {\n      // add component to tree\n      nextTree = tree.appendChild(stateNode); // change setState functionality\n\n      changeSetState(stateNode);\n    } // Check if the component uses hooks\n    // console.log(\"memoizedState\", memoizedState);\n\n\n    if (memoizedState && Object.hasOwnProperty.call(memoizedState, 'baseState')) {\n      // 'catch-all' for suspense elements (experimental)\n      if (typeof elementType.$$typeof === 'symbol') return; // Traverse through the currentFiber and extract the getters/setters\n\n      astHooks = astParser(elementType);\n      saveState(astHooks); // Create a traversed property and assign to the evaluated result of\n      // invoking traverseHooks with memoizedState\n\n      memoizedState.traversed = traverseHooks(memoizedState);\n      nextTree = tree.appendChild(memoizedState);\n    } // iterate through siblings\n\n\n    createTree(sibling, tree); // iterate through children\n\n    createTree(child, nextTree);\n    return tree;\n  } // runs when page initially loads\n  // but skips 1st hook click\n\n\n  async function updateSnapShotTree() {\n    let current; // if concurrent mode, grab current.child'\n\n    if (concurrent) {\n      // we need a way to wait for current child to populate\n      const promise = new Promise((resolve, reject) => {\n        setTimeout(() => resolve(fiberRoot.current.child), 400);\n      });\n      current = await promise;\n      current = fiberRoot.current.child;\n    } else {\n      current = fiberRoot.current;\n    }\n\n    snap.tree = createTree(current);\n  }\n\n  return async container => {\n    if (container._internalRoot) {\n      fiberRoot = container._internalRoot;\n      concurrent = true;\n    } else {\n      const _internalRoot = container._reactRootContainer._internalRoot,\n            _reactRootContainer = container._reactRootContainer; // only assign internal root if it actually exists\n\n      fiberRoot = _internalRoot || _reactRootContainer;\n    }\n\n    await updateSnapShotTree(); // send the initial snapshot once the content script has started up\n\n    window.addEventListener('message', ({\n      data: {\n        action\n      }\n    }) => {\n      if (action === 'contentScriptStarted') sendSnapshot();\n    });\n  };\n};","map":{"version":3,"sources":["/Users/josh/Documents/GitHub/calculator-reactime-sandbox/src/reactime-module/linkFiber.js"],"names":["Tree","require","astParser","saveState","module","exports","snap","mode","fiberRoot","astHooks","concurrent","sendSnapshot","jumping","paused","payload","tree","getCopy","window","postMessage","action","changeSetState","component","setState","linkFiberChanged","oldSetState","bind","state","callback","locked","updateSnapShotTree","changeUseState","queue","dispatch","oldDispatch","fiber","traverseHooks","memoizedState","memoized","index","Object","values","next","createTree","currentFiber","sibling","stateNode","child","elementType","nextTree","appendChild","hasOwnProperty","call","$$typeof","traversed","current","promise","Promise","resolve","reject","setTimeout","container","_internalRoot","_reactRootContainer","addEventListener","data"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\n/* eslint-disable func-names */\n/* eslint-disable no-use-before-define */\n/* eslint-disable no-param-reassign */\n// links component state tree to library\n// changes the setState method to also update our snapshot\nconst Tree = require('./tree');\nconst astParser = require('./astParser');\nconst { saveState } = require('./masterState');\n\nmodule.exports = (snap, mode) => {\n  let fiberRoot = null;\n  let astHooks;\n  let concurrent = false; // flag to check if we are in concurrent mode\n\n  function sendSnapshot() {\n    // don't send messages while jumping or while paused\n    // DEV: So that when we are jumping to an old snapshot it\n    // wouldn't think we want to create new snapshots\n    if (mode.jumping || mode.paused) return;\n    const payload = snap.tree.getCopy();\n    // console.log('payload', payload);\n    window.postMessage({\n      action: 'recordSnap',\n      payload,\n    });\n  }\n\n  function changeSetState(component) {\n    // check that setState hasn't been changed yet\n    if (component.setState.linkFiberChanged) return;\n    // make a copy of setState\n    const oldSetState = component.setState.bind(component);\n    // replace component's setState so developer doesn't change syntax\n    // component.setState = newSetState.bind(component);\n    component.setState = (state, callback = () => {}) => {\n      // don't do anything if state is locked\n      // UNLESS we are currently jumping through time\n      if (mode.locked && !mode.jumping) return;\n      // continue normal setState functionality, except add sending message middleware\n      oldSetState(state, () => {\n        updateSnapShotTree();\n        sendSnapshot();\n        callback.bind(component)();\n      });\n    };\n    component.setState.linkFiberChanged = true;\n  }\n\n  function changeUseState(component) {\n    if (component.queue.dispatch.linkFiberChanged) return;\n    // store the original dispatch function definition\n    const oldDispatch = component.queue.dispatch.bind(component.queue);\n    // redefine the dispatch function so we can inject our code\n    component.queue.dispatch = (fiber, queue, action) => {\n      // don't do anything if state is locked\n      if (mode.locked && !mode.jumping) return;\n      oldDispatch(fiber, queue, action);\n      // setTimeout(() => {\n      updateSnapShotTree();\n      sendSnapshot();\n      // }, 100);\n    };\n    component.queue.dispatch.linkFiberChanged = true;\n  }\n\n  // Helper function to traverse through the memoized state\n  // TODO: WE NEED TO CLEAN IT UP A BIT\n  function traverseHooks(memoizedState) {\n    // Declare variables and assigned to 0th index and an empty object, respectively\n    const memoized = {};\n    let index = 0;\n    astHooks = Object.values(astHooks);\n    // while memoizedState is truthy, save the value to the object\n    while (memoizedState && memoizedState.queue) {\n      // prevents useEffect from crashing on load\n      // if (memoizedState.next.queue === null) { // prevents double pushing snapshot updates\n      changeUseState(memoizedState);\n      // }\n      // memoized[astHooks[index]] = memoizedState.memoizedState;\n      memoized[astHooks[index]] = memoizedState.memoizedState;\n      // Reassign memoizedState to its next value\n      memoizedState = memoizedState.next;\n      // Increment the index by 2\n      index += 2;\n    }\n    return memoized;\n  }\n\n  function createTree(currentFiber, tree = new Tree('root')) {\n    if (!currentFiber) return tree;\n\n    const {\n      sibling,\n      stateNode,\n      child,\n      memoizedState,\n      elementType,\n    } = currentFiber;\n\n    let nextTree = tree;\n    // check if stateful component\n    if (stateNode && stateNode.state) {\n      // add component to tree\n      nextTree = tree.appendChild(stateNode);\n      // change setState functionality\n      changeSetState(stateNode);\n    }\n    // Check if the component uses hooks\n    // console.log(\"memoizedState\", memoizedState);\n\n    if (\n      memoizedState &&\n      Object.hasOwnProperty.call(memoizedState, 'baseState')\n    ) {\n      // 'catch-all' for suspense elements (experimental)\n      if (typeof elementType.$$typeof === 'symbol') return;\n      // Traverse through the currentFiber and extract the getters/setters\n      astHooks = astParser(elementType);\n      saveState(astHooks);\n      // Create a traversed property and assign to the evaluated result of\n      // invoking traverseHooks with memoizedState\n      memoizedState.traversed = traverseHooks(memoizedState);\n      nextTree = tree.appendChild(memoizedState);\n    }\n    // iterate through siblings\n    createTree(sibling, tree);\n    // iterate through children\n    createTree(child, nextTree);\n\n    return tree;\n  }\n  // runs when page initially loads\n  // but skips 1st hook click\n  async function updateSnapShotTree() {\n    let current;\n    // if concurrent mode, grab current.child'\n    if (concurrent) {\n      // we need a way to wait for current child to populate\n      const promise = new Promise((resolve, reject) => {\n        setTimeout(() => resolve(fiberRoot.current.child), 400);\n      });\n\n      current = await promise;\n\n      current = fiberRoot.current.child;\n    } else {\n      current = fiberRoot.current;\n    }\n\n    snap.tree = createTree(current);\n  }\n\n  return async container => {\n    if (container._internalRoot) {\n      fiberRoot = container._internalRoot;\n      concurrent = true;\n    } else {\n      const {\n        _reactRootContainer: { _internalRoot },\n        _reactRootContainer,\n      } = container;\n      // only assign internal root if it actually exists\n      fiberRoot = _internalRoot || _reactRootContainer;\n    }\n\n    await updateSnapShotTree();\n    // send the initial snapshot once the content script has started up\n    window.addEventListener('message', ({ data: { action } }) => {\n      if (action === 'contentScriptStarted') sendSnapshot();\n    });\n  };\n};\n"]},"metadata":{},"sourceType":"module"}