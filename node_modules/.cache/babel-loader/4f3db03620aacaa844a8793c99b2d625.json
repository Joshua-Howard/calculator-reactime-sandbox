{"ast":null,"code":"/* eslint-disable no-console */\n\n/* eslint-disable no-param-reassign */\n// this is the current snapshot that is being sent to the snapshots array.\nclass Tree {\n  constructor(component, useStateInstead = false, name) {\n    // special case when component is root\n    // give it a special state = 'root'\n    // a setState function that just calls the callback instantly\n    if (!useStateInstead) {\n      this.component = component === 'root' ? {\n        state: 'root',\n        setState: (partial, callback) => callback()\n      } : component;\n    } else {\n      this.state = component;\n      this.name = name;\n    }\n\n    this.children = []; // DEV: Added print() for debugging purposes\n    // this.print(); // this call is not useful here. it would be useful in a function call where we've already added to this.children\n  }\n\n  appendChild(component) {\n    const child = new Tree(component);\n    this.children.push(child);\n    return child;\n  } // deep copies only the state of each component and creates a new tree\n\n\n  getCopy(copy = new Tree('root', true)) {\n    // copy state of children\n    copy.children = this.children.map(child => new Tree(child.component.state || child.component.traversed, true, child.component.constructor.name)); // copy children's children recursively\n\n    this.children.forEach((child, i) => child.getCopy(copy.children[i]));\n    return copy;\n  } // print out the tree structure in the console\n  // DEV: Process may be different for useState components\n  // BUG FIX: Don't print the Router as a component\n  // Change how the children are printed\n\n\n  print() {\n    console.log(\"current tree structure for *this : \", this);\n    const children = ['children: ']; // DEV: What should we push instead for components using hooks (it wouldn't be state)\n\n    this.children.forEach(child => {\n      // if this.children is always initialized to empty array, when would there ever be anything to iterate through here?\n      children.push(child.state || child.component.state);\n    });\n    if (this.name) console.log(\"this.name if exists: \", this.name);\n\n    if (children.length === 1) {\n      console.log(\"children length 1. \".concat(this.state ? \"this.state: \" : \"this.component.state: \"), this.state || this.component.state);\n    } else console.log(\"children length !== 1. \".concat(this.state ? \"this.state: \" : \"this.component.state, children: \"), this.state || this.component.state, ...children);\n\n    this.children.forEach(child => {\n      child.print();\n    });\n  }\n\n}\n\nmodule.exports = Tree;","map":{"version":3,"sources":["/Users/josh/Documents/GitHub/calculator-reactime-sandbox/src/reactime-module/tree.js"],"names":["Tree","constructor","component","useStateInstead","name","state","setState","partial","callback","children","appendChild","child","push","getCopy","copy","map","traversed","forEach","i","print","console","log","length","module","exports"],"mappings":"AAAA;;AACA;AAEA;AACA,MAAMA,IAAN,CAAW;AACTC,EAAAA,WAAW,CAACC,SAAD,EAAYC,eAAe,GAAG,KAA9B,EAAqCC,IAArC,EAA2C;AACpD;AACA;AACA;AACA,QAAI,CAACD,eAAL,EAAsB;AACpB,WAAKD,SAAL,GAAiBA,SAAS,KAAK,MAAd,GACb;AAAEG,QAAAA,KAAK,EAAE,MAAT;AAAiBC,QAAAA,QAAQ,EAAE,CAACC,OAAD,EAAUC,QAAV,KAAuBA,QAAQ;AAA1D,OADa,GAEbN,SAFJ;AAGD,KAJD,MAIO;AACL,WAAKG,KAAL,GAAaH,SAAb;AACA,WAAKE,IAAL,GAAYA,IAAZ;AACD;;AACD,SAAKK,QAAL,GAAgB,EAAhB,CAZoD,CAapD;AAEA;AACD;;AAEDC,EAAAA,WAAW,CAACR,SAAD,EAAY;AACrB,UAAMS,KAAK,GAAG,IAAIX,IAAJ,CAASE,SAAT,CAAd;AACA,SAAKO,QAAL,CAAcG,IAAd,CAAmBD,KAAnB;AACA,WAAOA,KAAP;AACD,GAvBQ,CAyBT;;;AACAE,EAAAA,OAAO,CAACC,IAAI,GAAG,IAAId,IAAJ,CAAS,MAAT,EAAiB,IAAjB,CAAR,EAAgC;AACrC;AACAc,IAAAA,IAAI,CAACL,QAAL,GAAgB,KAAKA,QAAL,CAAcM,GAAd,CACdJ,KAAK,IAAI,IAAIX,IAAJ,CAASW,KAAK,CAACT,SAAN,CAAgBG,KAAhB,IACbM,KAAK,CAACT,SAAN,CAAgBc,SADZ,EACuB,IADvB,EAC6BL,KAAK,CAACT,SAAN,CAAgBD,WAAhB,CAA4BG,IADzD,CADK,CAAhB,CAFqC,CAOrC;;AACA,SAAKK,QAAL,CAAcQ,OAAd,CAAsB,CAACN,KAAD,EAAQO,CAAR,KAAcP,KAAK,CAACE,OAAN,CAAcC,IAAI,CAACL,QAAL,CAAcS,CAAd,CAAd,CAApC;AACA,WAAOJ,IAAP;AACD,GApCQ,CAsCT;AACA;AACA;AACA;;;AACAK,EAAAA,KAAK,GAAG;AACNC,IAAAA,OAAO,CAACC,GAAR,CAAY,qCAAZ,EAAmD,IAAnD;AACA,UAAMZ,QAAQ,GAAG,CAAC,YAAD,CAAjB,CAFM,CAGN;;AACA,SAAKA,QAAL,CAAcQ,OAAd,CAAsBN,KAAK,IAAI;AAAE;AAC/BF,MAAAA,QAAQ,CAACG,IAAT,CAAcD,KAAK,CAACN,KAAN,IAAeM,KAAK,CAACT,SAAN,CAAgBG,KAA7C;AACD,KAFD;AAGA,QAAI,KAAKD,IAAT,EAAegB,OAAO,CAACC,GAAR,CAAY,uBAAZ,EAAqC,KAAKjB,IAA1C;;AACf,QAAIK,QAAQ,CAACa,MAAT,KAAoB,CAAxB,EAA2B;AACzBF,MAAAA,OAAO,CAACC,GAAR,8BAAkC,KAAKhB,KAAL,4CAAlC,GAA4F,KAAKA,KAAL,IAAc,KAAKH,SAAL,CAAeG,KAAzH;AACD,KAFD,MAEOe,OAAO,CAACC,GAAR,kCAAsC,KAAKhB,KAAL,sDAAtC,GAA0G,KAAKA,KAAL,IAAc,KAAKH,SAAL,CAAeG,KAAvI,EAA8I,GAAGI,QAAjJ;;AACP,SAAKA,QAAL,CAAcQ,OAAd,CAAsBN,KAAK,IAAI;AAC7BA,MAAAA,KAAK,CAACQ,KAAN;AACD,KAFD;AAGD;;AAxDQ;;AA2DXI,MAAM,CAACC,OAAP,GAAiBxB,IAAjB","sourcesContent":["/* eslint-disable no-console */\n/* eslint-disable no-param-reassign */\n\n// this is the current snapshot that is being sent to the snapshots array.\nclass Tree {\n  constructor(component, useStateInstead = false, name) {\n    // special case when component is root\n    // give it a special state = 'root'\n    // a setState function that just calls the callback instantly\n    if (!useStateInstead) {\n      this.component = component === 'root'\n        ? { state: 'root', setState: (partial, callback) => callback() }\n        : component;\n    } else {\n      this.state = component;\n      this.name = name;\n    }\n    this.children = [];\n    // DEV: Added print() for debugging purposes\n\n    // this.print(); // this call is not useful here. it would be useful in a function call where we've already added to this.children\n  }\n\n  appendChild(component) {\n    const child = new Tree(component);\n    this.children.push(child);\n    return child;\n  }\n\n  // deep copies only the state of each component and creates a new tree\n  getCopy(copy = new Tree('root', true)) {\n    // copy state of children\n    copy.children = this.children.map(\n      child => new Tree(child.component.state\n        || child.component.traversed, true, child.component.constructor.name),\n    );\n\n    // copy children's children recursively\n    this.children.forEach((child, i) => child.getCopy(copy.children[i]));\n    return copy;\n  }\n\n  // print out the tree structure in the console\n  // DEV: Process may be different for useState components\n  // BUG FIX: Don't print the Router as a component\n  // Change how the children are printed\n  print() {\n    console.log(\"current tree structure for *this : \", this);\n    const children = ['children: '];\n    // DEV: What should we push instead for components using hooks (it wouldn't be state)\n    this.children.forEach(child => { // if this.children is always initialized to empty array, when would there ever be anything to iterate through here?\n      children.push(child.state || child.component.state);\n    });\n    if (this.name) console.log(\"this.name if exists: \", this.name);\n    if (children.length === 1) {\n      console.log(`children length 1. ${this.state ? `this.state: ` : `this.component.state: `}`, this.state || this.component.state);\n    } else console.log(`children length !== 1. ${this.state ? `this.state: ` : `this.component.state, children: `}`, this.state || this.component.state, ...children);\n    this.children.forEach(child => {\n      child.print();\n    });\n  }\n}\n\nmodule.exports = Tree;\n"]},"metadata":{},"sourceType":"module"}