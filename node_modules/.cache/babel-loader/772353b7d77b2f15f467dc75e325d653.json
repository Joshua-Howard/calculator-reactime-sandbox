{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable func-names */\n\n/* eslint-disable no-use-before-define */\n\n/* eslint-disable no-param-reassign */\n// links component state tree to library\n// changes the setState method to also update our snapshot\nconst Tree = require('./tree');\n\nconst astParser = require('./astParser');\n\nconst _require = require('./masterState'),\n      saveState = _require.saveState;\n\nmodule.exports = (snap, mode) => {\n  let fiberRoot = null;\n  let astHooks;\n  let concurrent = false; // flag to check if we are in concurrent mode\n\n  function sendSnapshot() {\n    // don't send messages while jumping or while paused\n    // DEV: So that when we are jumping to an old snapshot it\n    // wouldn't think we want to create new snapshots\n    if (mode.jumping || mode.paused) return;\n    const payload = snap.tree.getCopy(); // console.log('payload', payload);\n\n    window.postMessage({\n      action: 'recordSnap',\n      payload\n    });\n  }\n\n  function changeSetState(component) {\n    // check that setState hasn't been changed yet\n    if (component.setState.linkFiberChanged) return; // make a copy of setState\n\n    const oldSetState = component.setState.bind(component); // replace component's setState so developer doesn't change syntax\n    // component.setState = newSetState.bind(component);\n\n    component.setState = (state, callback = () => {}) => {\n      // don't do anything if state is locked\n      // UNLESS we are currently jumping through time\n      if (mode.locked && !mode.jumping) return; // continue normal setState functionality, except add sending message middleware\n\n      oldSetState(state, () => {\n        updateSnapShotTree();\n        sendSnapshot();\n        callback.bind(component)();\n      });\n    };\n\n    component.setState.linkFiberChanged = true;\n  }\n\n  function changeUseState(component) {\n    if (component.queue.dispatch.linkFiberChanged) return; // store the original dispatch function definition\n\n    const oldDispatch = component.queue.dispatch.bind(component.queue); // redefine the dispatch function so we can inject our code\n\n    component.queue.dispatch = (fiber, queue, action) => {\n      // don't do anything if state is locked\n      if (mode.locked && !mode.jumping) return;\n      oldDispatch(fiber, queue, action); // setTimeout(() => {\n\n      updateSnapShotTree();\n      sendSnapshot(); // }, 100);\n    };\n\n    component.queue.dispatch.linkFiberChanged = true;\n  } // Helper function to traverse through the memoized state\n  // TODO: WE NEED TO CLEAN IT UP A BIT\n\n\n  function traverseHooks(memoizedState) {\n    // Declare variables and assigned to 0th index and an empty object, respectively\n    const memoized = {};\n    let index = 0;\n    astHooks = Object.values(astHooks); // while memoizedState is truthy, save the value to the object\n\n    while (memoizedState && memoizedState.queue) {\n      // prevents useEffect from crashing on load\n      // if (memoizedState.next.queue === null) { // prevents double pushing snapshot updates\n      changeUseState(memoizedState); // }\n      // memoized[astHooks[index]] = memoizedState.memoizedState;\n\n      memoized[astHooks[index]] = memoizedState.memoizedState; // Reassign memoizedState to its next value\n\n      memoizedState = memoizedState.next; // Increment the index by 2\n\n      index += 2;\n    }\n\n    return memoized;\n  }\n\n  function createTree(currentFiber, tree = new Tree('root')) {\n    if (!currentFiber) return tree;\n    const sibling = currentFiber.sibling,\n          stateNode = currentFiber.stateNode,\n          child = currentFiber.child,\n          memoizedState = currentFiber.memoizedState,\n          elementType = currentFiber.elementType;\n    let nextTree = tree; // check if stateful component\n\n    if (stateNode && stateNode.state) {\n      // add component to tree\n      nextTree = tree.appendChild(stateNode); // change setState functionality\n\n      changeSetState(stateNode);\n    } // Check if the component uses hooks\n    // console.log(\"memoizedState\", memoizedState);\n\n\n    if (memoizedState && Object.hasOwnProperty.call(memoizedState, 'baseState')) {\n      // 'catch-all' for suspense elements (experimental)\n      if (typeof elementType.$$typeof === 'symbol') return; // Traverse through the currentFiber and extract the getters/setters\n\n      astHooks = astParser(elementType);\n      saveState(astHooks); // Create a traversed property and assign to the evaluated result of\n      // invoking traverseHooks with memoizedState\n\n      memoizedState.traversed = traverseHooks(memoizedState);\n      nextTree = tree.appendChild(memoizedState);\n    } // iterate through siblings\n\n\n    createTree(sibling, tree); // iterate through children\n\n    createTree(child, nextTree);\n    return tree;\n  } // runs when page initially loads\n  // but skips 1st hook click\n\n\n  async function updateSnapShotTree() {\n    let current; // if concurrent mode, grab current.child'\n\n    if (concurrent) {\n      // we need a way to wait for current child to populate\n      const promise = new Promise((resolve, reject) => {\n        setTimeout(() => resolve(fiberRoot.current.child), 400);\n      });\n      current = await promise;\n      current = fiberRoot.current.child;\n    } else {\n      current = fiberRoot.current;\n    }\n\n    snap.tree = createTree(current);\n  }\n\n  return async container => {\n    if (container._internalRoot) {\n      fiberRoot = container._internalRoot;\n      concurrent = true;\n    } else {\n      const _internalRoot = container._reactRootContainer._internalRoot,\n            _reactRootContainer = container._reactRootContainer; // only assign internal root if it actually exists\n\n      fiberRoot = _internalRoot || _reactRootContainer;\n    }\n\n    await updateSnapShotTree(); // send the initial snapshot once the content script has started up\n\n    window.addEventListener('message', ({\n      data: {\n        action\n      }\n    }) => {\n      if (action === 'contentScriptStarted') sendSnapshot();\n    });\n  };\n};","map":null,"metadata":{},"sourceType":"script"}