{"ast":null,"code":"/* eslint-disable no-inner-declarations */\nconst acorn = require('acorn'); // javascript parser\n// eslint-disable-next-line import/newline-after-import\n\n\nconst jsx = require('acorn-jsx');\n\nconst JSXParser = acorn.Parser.extend(jsx()); // Helper function to grab the getters/setters from `elementType`\n\nmodule.exports = elementType => {\n  // Initialize empty object to store the setters and getter\n  let ast = JSXParser.parse(elementType);\n  const hookState = {};\n\n  while (Object.hasOwnProperty.call(ast, 'body')) {\n    ast = ast.body;\n    const statements = [];\n    /** All module exports always start off as a single 'FunctionDeclaration' type\n     * Other types: \"BlockStatement\" / \"ExpressionStatement\" / \"ReturnStatement\"\n     * Iterate through AST of every function declaration\n     * Check within each function declaration if there are hook declarations */\n\n    ast.forEach(functionDec => {\n      let body;\n      if (functionDec.expression) body = functionDec.expression.body.body;else body = functionDec.body.body; // Traverse through the function's funcDecs and Expression Statements\n\n      body.forEach(elem => {\n        if (elem.type === 'VariableDeclaration') {\n          elem.declarations.forEach(hook => {\n            statements.push(hook.id.name);\n          });\n        }\n      }); // Iterate array and determine getter/setters based on pattern\n\n      statements.forEach((el, i) => {\n        if (el.match(/_use/)) hookState[el] = statements[i + 2];\n      });\n    });\n  }\n\n  return hookState;\n};","map":{"version":3,"sources":["/Users/josh/Documents/GitHub/calculator-reactime-sandbox/src/reactime-module/astParser.js"],"names":["acorn","require","jsx","JSXParser","Parser","extend","module","exports","elementType","ast","parse","hookState","Object","hasOwnProperty","call","body","statements","forEach","functionDec","expression","elem","type","declarations","hook","push","id","name","el","i","match"],"mappings":"AAAA;AACA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB,C,CAAgC;AAChC;;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,WAAD,CAAnB;;AACA,MAAME,SAAS,GAAGH,KAAK,CAACI,MAAN,CAAaC,MAAb,CAAoBH,GAAG,EAAvB,CAAlB,C,CAEA;;AACAI,MAAM,CAACC,OAAP,GAAiBC,WAAW,IAAI;AAC9B;AACA,MAAIC,GAAG,GAAGN,SAAS,CAACO,KAAV,CAAgBF,WAAhB,CAAV;AACA,QAAMG,SAAS,GAAG,EAAlB;;AAEA,SAAOC,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BL,GAA3B,EAAgC,MAAhC,CAAP,EAAgD;AAC9CA,IAAAA,GAAG,GAAGA,GAAG,CAACM,IAAV;AACA,UAAMC,UAAU,GAAG,EAAnB;AAEA;;;;;AAIAP,IAAAA,GAAG,CAACQ,OAAJ,CAAYC,WAAW,IAAI;AACzB,UAAIH,IAAJ;AACA,UAAIG,WAAW,CAACC,UAAhB,EAA4BJ,IAAI,GAAGG,WAAW,CAACC,UAAZ,CAAuBJ,IAAvB,CAA4BA,IAAnC,CAA5B,KACKA,IAAI,GAAGG,WAAW,CAACH,IAAZ,CAAiBA,IAAxB,CAHoB,CAIzB;;AACAA,MAAAA,IAAI,CAACE,OAAL,CAAaG,IAAI,IAAI;AACnB,YAAIA,IAAI,CAACC,IAAL,KAAc,qBAAlB,EAAyC;AACvCD,UAAAA,IAAI,CAACE,YAAL,CAAkBL,OAAlB,CAA0BM,IAAI,IAAI;AAChCP,YAAAA,UAAU,CAACQ,IAAX,CAAgBD,IAAI,CAACE,EAAL,CAAQC,IAAxB;AACD,WAFD;AAGD;AACF,OAND,EALyB,CAazB;;AACAV,MAAAA,UAAU,CAACC,OAAX,CAAmB,CAACU,EAAD,EAAKC,CAAL,KAAW;AAC5B,YAAID,EAAE,CAACE,KAAH,CAAS,MAAT,CAAJ,EAAsBlB,SAAS,CAACgB,EAAD,CAAT,GAAgBX,UAAU,CAACY,CAAC,GAAG,CAAL,CAA1B;AACvB,OAFD;AAGD,KAjBD;AAkBD;;AACD,SAAOjB,SAAP;AACD,CAjCD","sourcesContent":["/* eslint-disable no-inner-declarations */\nconst acorn = require('acorn'); // javascript parser\n// eslint-disable-next-line import/newline-after-import\nconst jsx = require('acorn-jsx');\nconst JSXParser = acorn.Parser.extend(jsx());\n\n// Helper function to grab the getters/setters from `elementType`\nmodule.exports = elementType => {\n  // Initialize empty object to store the setters and getter\n  let ast = JSXParser.parse(elementType);\n  const hookState = {};\n\n  while (Object.hasOwnProperty.call(ast, 'body')) {\n    ast = ast.body;\n    const statements = [];\n\n    /** All module exports always start off as a single 'FunctionDeclaration' type\n     * Other types: \"BlockStatement\" / \"ExpressionStatement\" / \"ReturnStatement\"\n     * Iterate through AST of every function declaration\n     * Check within each function declaration if there are hook declarations */\n    ast.forEach(functionDec => {\n      let body;\n      if (functionDec.expression) body = functionDec.expression.body.body;\n      else body = functionDec.body.body;\n      // Traverse through the function's funcDecs and Expression Statements\n      body.forEach(elem => {\n        if (elem.type === 'VariableDeclaration') {\n          elem.declarations.forEach(hook => {\n            statements.push(hook.id.name);\n          });\n        }\n      });\n\n      // Iterate array and determine getter/setters based on pattern\n      statements.forEach((el, i) => {\n        if (el.match(/_use/)) hookState[el] = statements[i + 2];\n      });\n    });\n  }\n  return hookState;\n};\n"]},"metadata":{},"sourceType":"module"}